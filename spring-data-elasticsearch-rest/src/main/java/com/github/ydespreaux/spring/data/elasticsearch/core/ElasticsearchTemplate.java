/* * Copyright (C) 2018 Yoann Despréaux * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; see the file COPYING . If not, write to the * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. * * Please send bugreports with examples or suggestions to yoann.despreaux@believeit.fr */package com.github.ydespreaux.spring.data.elasticsearch.core;import com.github.ydespreaux.spring.data.elasticsearch.client.RestElasticsearchClient;import com.github.ydespreaux.spring.data.elasticsearch.config.IngestTemplate;import com.github.ydespreaux.spring.data.elasticsearch.core.converter.ElasticsearchConverter;import com.github.ydespreaux.spring.data.elasticsearch.core.mapping.ElasticsearchPersistentEntity;import com.github.ydespreaux.spring.data.elasticsearch.core.query.*;import com.github.ydespreaux.spring.data.elasticsearch.core.request.config.RolloverConfig;import com.github.ydespreaux.spring.data.elasticsearch.core.scroll.ScrolledPageResult;import com.github.ydespreaux.spring.data.elasticsearch.core.triggers.RolloverTrigger;import com.github.ydespreaux.spring.data.elasticsearch.core.triggers.TriggerManager;import lombok.extern.slf4j.Slf4j;import org.elasticsearch.ElasticsearchException;import org.elasticsearch.ElasticsearchStatusException;import org.elasticsearch.action.admin.indices.alias.Alias;import org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;import org.elasticsearch.action.admin.indices.get.GetIndexRequest;import org.elasticsearch.action.admin.indices.rollover.RolloverRequest;import org.elasticsearch.action.admin.indices.template.get.GetIndexTemplatesRequest;import org.elasticsearch.action.admin.indices.template.get.GetIndexTemplatesResponse;import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateRequest;import org.elasticsearch.action.bulk.BulkItemResponse;import org.elasticsearch.action.bulk.BulkRequest;import org.elasticsearch.action.bulk.BulkResponse;import org.elasticsearch.action.delete.DeleteRequest;import org.elasticsearch.action.get.GetRequest;import org.elasticsearch.action.get.GetResponse;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.action.index.IndexResponse;import org.elasticsearch.action.search.*;import org.elasticsearch.client.GetAliasesResponse;import org.elasticsearch.client.Request;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.Response;import org.elasticsearch.cluster.metadata.AliasMetaData;import org.elasticsearch.index.query.QueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.reindex.BulkByScrollResponse;import org.elasticsearch.index.reindex.DeleteByQueryRequest;import org.elasticsearch.rest.RestStatus;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.core.io.Resource;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.lang.Nullable;import org.springframework.util.Assert;import org.springframework.util.StringUtils;import java.io.IOException;import java.time.Duration;import java.util.*;import static org.elasticsearch.client.Requests.refreshRequest;/** * Class define the Elastic Search operations. * * @author Yoann Despréaux * @since 1.0.0 */@Slf4jpublic class ElasticsearchTemplate extends ElasticsearchTemplateSupport implements ElasticsearchOperations {    /**     * RestHighLevelClient client.     */    private final RestElasticsearchClient client;    /**     *     */    private IngestTemplate ingestTemplate;    /**     * Construct an instance with the given client and elasticsearchConverter parameters.     *     * @param client                 the given client.     * @param elasticsearchConverter the given elasticsearchConverter.     * @param resultsMapper          the given result mapper     */    public ElasticsearchTemplate(final RestElasticsearchClient client,                                 final ElasticsearchConverter elasticsearchConverter,                                 final ResultsMapper resultsMapper,                                 final TriggerManager triggerManager) {        super(elasticsearchConverter, resultsMapper, triggerManager);        this.client = client;    }    /**     * @param ingest     */    public void setIngestTemplate(IngestTemplate ingest) {        this.ingestTemplate = ingest;    }    /**     * @param applicationContext     * @see ApplicationContextAware#setApplicationContext(ApplicationContext)  method     */    @Override    public void setApplicationContext(ApplicationContext applicationContext) {        super.setApplicationContext(applicationContext);        if (this.ingestTemplate != null) {            this.ingestTemplate.setApplicationContext(applicationContext);        }    }    @Override    public void afterPropertiesSet() {        if (this.ingestTemplate != null) {            this.ingestTemplate.ingest();        }    }    /**     * @param request the request parameter     * @return the reponse of the result request     */    @Override    public Response performRequest(Request request) throws IOException {        return client.getRestHighLevelClient().getLowLevelClient().performRequest(request);    }    /**     * @see ElasticsearchOperations#createTemplate(String, String, Boolean)  method     */    @Override    public void createTemplate(String templateName, String location, Boolean createOnly) {        Resource resource = getResource(location);        if (!resource.exists()) {            throw new ElasticsearchException("File {} not found", location);        }        createTemplate(templateName, Collections.singletonList(resource), createOnly);    }    /**     * @see ElasticsearchOperations#createTemplate(String, String, Boolean)  method     */    @Override    public void createTemplate(String templateName, List<Resource> locations, Boolean createOnly) {        if (createOnly && templateExists(templateName)) {            return;        }        PutIndexTemplateRequest templateRequest = this.requestsBuilder().createPutIndexTemplateRequest(templateName, locations);        try {            this.client.putTemplate(templateRequest);            if (log.isDebugEnabled()) {                log.debug("New template {} added : {}", templateName, templateRequest.toString());            }        } catch (IOException e) {            throw new ElasticsearchException("Error for request: " + templateRequest.toString(), e);        }    }    /**     * @see ElasticsearchOperations#templateExists(String)  method     */    @Override    public boolean templateExists(String templateName) {        GetIndexTemplatesRequest request = new GetIndexTemplatesRequest(templateName);        try {            GetIndexTemplatesResponse response = this.client.getTemplates(request);            return !response.getIndexTemplates().isEmpty();        } catch (ElasticsearchStatusException e) {            if (e.status() == RestStatus.NOT_FOUND) {                return false;            }            throw new ElasticsearchException("Error for Get template request: " + request.toString(), e);        } catch (IOException e) {            throw new ElasticsearchException("Error for Get template request: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#deleteTemplate(String)  method     */    @Override    public void deleteTemplate(String templateName) {        if (templateExists(templateName)) {            Request request = this.requestsBuilder().deleteTemplateRequest(templateName);            try {                this.performRequest(request);                if (log.isDebugEnabled()) {                    log.debug("Deleted template {}", templateName);                }            } catch (IOException e) {                throw new ElasticsearchException("Error for delete template request: " + request.toString(), e);            }        }    }    /**     * @see ElasticsearchOperations#deleteIndexByName(String)   method     */    @Override    public boolean deleteIndexByName(String indexName) {        Objects.requireNonNull(indexName);        DeleteIndexRequest request = this.requestsBuilder().deleteIndexRequest(indexName);        try {            boolean deleted = this.client.deleteIndex(request).isAcknowledged();            if (log.isDebugEnabled() && deleted) {                log.debug("Deleted index {}", indexName);            }            return deleted;        } catch (ElasticsearchStatusException e) {            if (e.status() == RestStatus.NOT_FOUND) {                return false;            }            throw buildDeleteException(e, request);        } catch (IOException e) {            throw buildDeleteException(e, request);        }    }    /**     * @see ElasticsearchOperations#deleteIndexByAlias(String)    method     */    @Override    public void deleteIndexByAlias(String aliasName) {        Objects.requireNonNull(aliasName);        GetAliasesRequest request = new GetAliasesRequest(aliasName);        try {            Map<String, Set<AliasMetaData>> indices = this.client.getAlias(request).getAliases();            indices.keySet().forEach(this::deleteIndexByName);        } catch (IOException e) {            throw buildGetAliasException(e, request);        }    }    /**     * Check if Index Exist     *     * @param indexName the index name     * @return true if index exist     */    @Override    public boolean indexExists(String indexName) {        Objects.requireNonNull(indexName);        GetIndexRequest request = this.requestsBuilder().getIndexRequest(indexName);        try {            return client.indicesExist(request, RequestOptions.DEFAULT);        } catch (IOException e) {            throw new ElasticsearchException("Error while for indexExists request: " + request.toString(), e);        }    }    /**     * @param clazz     * @param <T>     * @return     */    @Override    public <T> boolean createIndex(Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (persistentEntity.isRolloverIndex()) {            return createRolloverIndex(persistentEntity);        } else {            return createIndex(persistentEntity);        }    }    /**     * @param alias     * @param indexName     * @return     */    @Override    public boolean createIndex(@Nullable Alias alias, String indexName) {        Assert.notNull(indexName, "No index defined for Query");        try {            return client.createIndex(this.requestsBuilder().createIndexRequest(alias, indexName)).isAcknowledged();        } catch (Exception e) {            throw new ElasticsearchException("Failed to create index " + indexName, e);        }    }    /**     *     * @param aliasReader     * @param aliasWriter     * @param indexName     * @return     */    @Override    public boolean createRolloverIndex(@Nullable Alias aliasReader, Alias aliasWriter, String indexName) {        return doCreateIndex(this.requestsBuilder().createRolloverIndex(aliasReader, aliasWriter, generateRolloverIndexName(indexName)));    }    /**     *     * @param alias     * @param indexName     * @param indexPath     * @return     */    @Override    public boolean createIndexWithSettingsAndMapping(@Nullable Alias alias, String indexName, String indexPath) {        return doCreateIndex(this.requestsBuilder().createIndexRequest(alias, indexName, indexPath));    }    /**     *     * @param aliasReader     * @param aliasWriter     * @param indexName     * @param indexPath     * @return     */    @Override    public boolean createRolloverIndexWithSettingsAndMapping(@Nullable Alias aliasReader, Alias aliasWriter, String indexName, String indexPath) {        return doCreateIndex(this.requestsBuilder().createRolloverIndex(aliasReader, aliasWriter, generateRolloverIndexName(indexName), indexPath));    }    /**     * @param request     * @return     */    private boolean doCreateIndex(CreateIndexRequest request) {        try {            return this.client.createIndex(request).isAcknowledged();        } catch (IOException e) {            throw new ElasticsearchException("Failed to create index request: " + request.toString(), e);        }    }    /**     * @param persistentEntity     * @param <T>     * @return     */    private <T> boolean createIndex(ElasticsearchPersistentEntity<T> persistentEntity) {        String indexReader = persistentEntity.getAliasOrIndexReader();        if (persistentEntity.createIndex() && !indexExists(indexReader)) {            String newIndexName = persistentEntity.getIndexName();            if (persistentEntity.isIndexTimeBased()) {                return createIndex(newIndexName);            } else if (StringUtils.hasText(persistentEntity.getIndexSettingAndMappingPath())) {                return createIndexWithSettingsAndMapping(persistentEntity.getAlias(), newIndexName, persistentEntity.getIndexSettingAndMappingPath());            } else {                return createIndex(persistentEntity.getAlias(), newIndexName);            }        }        return false;    }    /**     * @param persistentEntity     * @param <T>     * @return     */    private <T> boolean createRolloverIndex(ElasticsearchPersistentEntity<T> persistentEntity) {        boolean indexCreated = false;        RolloverConfig rolloverConfig = persistentEntity.getRolloverConfig();        if (persistentEntity.createIndex() && !indexExists(rolloverConfig.getAlias().getName())) {            String newIndexName = persistentEntity.getIndexName();            if (persistentEntity.isIndexTimeBased()) {                indexCreated = createRolloverIndex(null, rolloverConfig.getDefaultAlias(), newIndexName);            } else if (!StringUtils.isEmpty(persistentEntity.getIndexSettingAndMappingPath())) {                indexCreated = createRolloverIndexWithSettingsAndMapping(persistentEntity.getAlias(), rolloverConfig.getDefaultAlias(), newIndexName, persistentEntity.getIndexSettingAndMappingPath());            } else {                indexCreated = createRolloverIndex(persistentEntity.getAlias(), rolloverConfig.getDefaultAlias(), newIndexName);            }        }        RolloverConfig.TriggerConfig triggerConfig = rolloverConfig.getTrigger();        if (triggerConfig.isEnabled()) {            getTriggerManager().startTrigger(new RolloverTrigger(this, persistentEntity, triggerConfig.getCronExpression()));        }        return indexCreated;    }    /**     *     * @param clazz     * @param <T>     * @return     */    @Override    public <T> boolean rolloverIndex(Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        RolloverConfig rollover = persistentEntity.getRolloverConfig();        return rolloverIndex(                rollover.getAlias().getName(),                persistentEntity.getIndexSettingAndMappingPath(),                rollover.getConditions()        );    }    /**     * @param aliasName     * @param indexPath     * @param conditions     * @return     */    @Override    public boolean rolloverIndex(String aliasName, String indexPath, RolloverConfig.RolloverConditions conditions) {        RolloverRequest request = this.requestsBuilder().rolloverRequest(aliasName, indexPath, conditions);        try {            return this.client.rollover(request).isAcknowledged();        } catch (IOException e) {            throw new ElasticsearchException("Failed to rollover index request: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#index(Object, Class)     method     */    @Override    public <T> T index(T entity, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        IndexRequest request = this.requestsBuilder().indexRequest(entity, persistentEntity, this.getResultsMapper());        try {            IndexResponse response = client.index(request);            persistentEntity.setPersistentEntity(entity, response);            return entity;        } catch (IOException e) {            throw new ElasticsearchException("Error while index for request: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#bulkIndex(List, Class) method     */    @Override    public <T> List<T> bulkIndex(List<T> entities, Class<T> clazz) {        if (entities.isEmpty())            return entities;        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        BulkRequest bulkRequest = new BulkRequest();        entities.forEach(entity -> bulkRequest.add(this.requestsBuilder().indexRequest(entity, persistentEntity, this.getResultsMapper())));        try {            BulkResponse response = client.bulk(bulkRequest);            checkForBulkUpdateFailure(response);            BulkItemResponse[] items = response.getItems();            for (int i = 0; i < entities.size(); i++) {                persistentEntity.setPersistentEntity(entities.get(i), items[i]);            }            return entities;        } catch (IOException e) {            throw new ElasticsearchException("Error while bulk for request: " + bulkRequest.toString(), e);        }    }    @Override    public List bulkIndex(List<?> entities) {        if (entities.isEmpty())            return entities;        BulkRequest bulkRequest = new BulkRequest();        entities.forEach(entity -> {            Class entityClass = entity.getClass();            ElasticsearchPersistentEntity persistentEntity = getPersistentEntityFor(entityClass);            bulkRequest.add(this.requestsBuilder().indexRequest(entity, persistentEntity, this.getResultsMapper()));        });        try {            BulkResponse response = client.bulk(bulkRequest);            checkForBulkUpdateFailure(response);            BulkItemResponse[] items = response.getItems();            for (int i = 0; i < entities.size(); i++) {                Object entity = entities.get(i);                ElasticsearchPersistentEntity persistentEntity = getPersistentEntityFor(entity.getClass());                persistentEntity.setPersistentEntity(entities.get(i), items[i]);            }            return entities;        } catch (IOException e) {            throw new ElasticsearchException("Error while bulk for request: " + bulkRequest.toString(), e);        }    }    /**     * @see ElasticsearchOperations#findById(Class, String)  method     */    @Override    public <T> Optional<T> findById(Class<T> clazz, String documentId) {        Objects.requireNonNull(documentId, "documentId parameter canno't be null !");        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (persistentEntity.isIndexTimeBased() || persistentEntity.isRolloverIndex()) {            SearchQuery query = new NativeSearchQuery.NativeSearchQueryBuilder()                    .withQuery(QueryBuilders.termQuery("_id", documentId))                    .withPageable(PageRequest.of(0, 1))                    .build();            return findOne(query, clazz);        } else {            GetRequest request = this.requestsBuilder().getRequest(persistentEntity.getAliasOrIndexReader(), persistentEntity.getTypeName(), documentId);            try {                GetResponse response = client.get(request);                return Optional.ofNullable(this.getResultsMapper().mapResult(response, clazz));            } catch (ElasticsearchStatusException e) {                if (e.status() == RestStatus.NOT_FOUND) {                    return Optional.empty();                }                throw new ElasticsearchException("Error for delete index request: " + request.toString(), e);            } catch (IOException e) {                throw new ElasticsearchException("Error while getting for request: " + request.toString(), e);            }        }    }    @Override    public <T> Optional<T> findOne(CriteriaQuery query, Class<T> clazz) {        return getResultOne(this.search(query, clazz));    }    @Override    public <T> Optional<T> findOne(SearchQuery query, Class<T> clazz) {        return getResultOne(this.search(query, clazz));    }    @Override    public <T> Optional<T> findOne(StringQuery query, Class<T> clazz) {        return getResultOne(this.search(query, clazz));    }    private <T> Optional<T> getResultOne(List<T> items) {        if (items.isEmpty()) {            return Optional.empty();        }        return Optional.of(items.get(0));    }    /**     * @param query     * @param clazz     * @return     */    @Override    public <T> long count(SearchQuery query, Class<T> clazz) {        return executeCount(doCount(prepareCount(query, clazz), query));    }    /**     * @param criteriaQuery     * @param clazz     * @return     */    @Override    public <T> long count(CriteriaQuery criteriaQuery, Class<T> clazz) {        return executeCount(doCount(prepareCount(criteriaQuery, clazz), criteriaQuery));    }    /**     * @param searchRequest     * @return     */    private long executeCount(SearchRequest searchRequest) {        try {            return client.search(searchRequest).getHits().getTotalHits();        } catch (IOException e) {            throw buildSearchException(e, searchRequest);        }    }    @Override    public <T> Boolean existsById(Class<T> clazz, String documentId) {        Objects.requireNonNull(documentId, "documentId parameter canno't be null !");        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (persistentEntity.isIndexTimeBased() || persistentEntity.isRolloverIndex()) {            FetchSourceFilter.FetchSourceFilterBuilder sourceBuilder = new FetchSourceFilter.FetchSourceFilterBuilder();            sourceBuilder.withIncludes("id");            SearchQuery query = new NativeSearchQuery.NativeSearchQueryBuilder()                    .withQuery(QueryBuilders.termQuery("_id", documentId))                    .withSourceFilter(sourceBuilder.build())                    .withPageable(PageRequest.of(0, 1))                    .build();            SearchResponse response = executeSearch(doSearch(prepareSearch(query, clazz), query));            return response.getHits().totalHits > 0;        } else {            GetRequest request = this.requestsBuilder().getRequest(persistentEntity.getAliasOrIndexReader(), persistentEntity.getTypeName(), documentId);            try {                return client.exists(request);            } catch (ElasticsearchStatusException e) {                if (e.status() == RestStatus.NOT_FOUND) {                    return false;                }                throw new ElasticsearchException("Error for delete index request: " + request.toString(), e);            } catch (IOException e) {                throw new ElasticsearchException("Error while getting for request: " + request.toString(), e);            }        }    }    /**     * @param query     * @param javaType     * @return     */    @Override    public <T> Boolean existsByQuery(CriteriaQuery query, Class<T> javaType) {        SearchResponse response = executeSearch(doSearch(prepareSearch(query, javaType), query));        return response.getHits().totalHits > 0;    }    @Override    public <T> Boolean existsByQuery(SearchQuery query, Class<T> javaType) {        SearchResponse response = executeSearch(doSearch(prepareSearch(query, javaType), query));        return response.getHits().totalHits > 0;    }    @Override    public <T> Boolean existsByQuery(StringQuery query, Class<T> javaType) {        SearchResponse response = executeSearch(doSearch(prepareSearch(query, javaType), query));        return response.getHits().totalHits > 0;    }    @Override    public <S extends T, T> List<S> search(SearchQuery query, Class<T> clazz) {        SearchResponse response = executeSearch(doSearch(prepareSearch(query, clazz), query));        return this.getResultsMapper().mapEntity(response.getHits(), clazz);    }    /**     * @param criteriaQuery     * @param clazz     * @return     */    @Override    public <S extends T, T> List<S> search(CriteriaQuery criteriaQuery, Class<T> clazz) {        SearchResponse response = executeSearch(doSearch(prepareSearch(criteriaQuery, clazz), criteriaQuery));        return this.getResultsMapper().mapEntity(response.getHits(), clazz);    }    /**     * @param stringQuery     * @param clazz     * @return     */    @Override    public <S extends T, T> List<S> search(StringQuery stringQuery, Class<T> clazz) {        SearchResponse response = executeSearch(doSearch(prepareSearch(stringQuery, clazz), stringQuery));        return this.getResultsMapper().mapEntity(response.getHits(), clazz);    }    /**     * Start the {@link Page}, with the given scrollTime, size, builder and clazz.     *     * @param searchQuery the given query.     * @param clazz       the given {@link Class} clazz.     * @return a {@link Page} of T instances.     */    @Override    public <S extends T, T> Page<S> startScroll(SearchQuery searchQuery, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = this.getPersistentEntityFor(clazz);        return this.startScroll(persistentEntity.getScrollTime(), searchQuery, clazz);    }    /**     * @param scrollTime  the scroll time.     * @param searchQuery the given query.     * @param clazz       the given {@link Class} clazz.     * @param <T>         the items type     * @return the scrolled page for the current continueScroll     */    @Override    public <S extends T, T> Page<S> startScroll(Duration scrollTime, SearchQuery searchQuery, Class<T> clazz) {        return this.startScroll(scrollTime, searchQuery, clazz, this.getResultsMapper());    }    /**     * Start the {@link Page}, with the given scrollTime, size, builder and clazz.     *     * @param criteriaQuery the given query.     * @param clazz         the given {@link Class} clazz.     * @return a {@link Page} of T instances.     */    @Override    public <S extends T, T> Page<S> startScroll(CriteriaQuery criteriaQuery, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = this.getPersistentEntityFor(clazz);        return this.startScroll(persistentEntity.getScrollTime(), criteriaQuery, clazz);    }    /**     * @param scrollTime     * @param criteriaQuery     * @param clazz     * @return     */    @Override    public <S extends T, T> Page<S> startScroll(Duration scrollTime, CriteriaQuery criteriaQuery, Class<T> clazz) {        return this.startScroll(scrollTime, criteriaQuery, clazz, this.getResultsMapper());    }    /**     * Start the {@link Page}, with the given scrollTime, size, builder and clazz.     *     * @param stringQuery the given query.     * @param clazz       the given {@link Class} clazz.     * @return a {@link Page} of T instances.     */    @Override    public <S extends T, T> Page<S> startScroll(StringQuery stringQuery, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = this.getPersistentEntityFor(clazz);        return this.startScroll(persistentEntity.getScrollTime(), stringQuery, clazz);    }    /**     * Start the {@link Page}, with the given scrollTime, size, builder and clazz.     *     * @param scrollTime  the scroll time.     * @param stringQuery the given query.     * @param clazz       the given {@link Class} clazz.     * @return a {@link Page} of T instances.     */    @Override    public <S extends T, T> Page<S> startScroll(Duration scrollTime, StringQuery stringQuery, Class<T> clazz) {        return this.startScroll(scrollTime, stringQuery, clazz, this.getResultsMapper());    }    /**     * @param scrollTime     * @param searchQuery     * @param entityType     * @return     */    public <T> SearchResponse startScrollResponse(Duration scrollTime, SearchQuery searchQuery, Class<T> entityType) {        return executeSearch(doScroll(prepareScroll(searchQuery, scrollTime, entityType), searchQuery));    }    /**     * @param scrollTime     * @param searchQuery     * @return     */    public SearchResponse startScrollResponse(Duration scrollTime, SearchQuery searchQuery) {        return executeSearch(doScroll(prepareScroll(searchQuery, scrollTime), searchQuery));    }    /**     * @param scrollTime  the scroll time     * @param searchQuery the query     * @param clazz       the domain type     * @param mapper      the mapper     * @param <T>         the generic type     * @return the scrolled page for the current continueScroll     */    @Override    public <S extends T, T> Page<S> startScroll(Duration scrollTime, SearchQuery searchQuery, Class<T> clazz, SearchResultMapper mapper) {        SearchResponse response = startScrollResponse(scrollTime, searchQuery, clazz);        return mapper.mapResults(response, clazz);    }    /**     * @param scrollTime     * @param criteriaQuery     * @param entityType     * @param <T>     * @return     */    public <T> SearchResponse startScrollResponse(Duration scrollTime, CriteriaQuery criteriaQuery, Class<T> entityType) {        return executeSearch(doScroll(prepareScroll(criteriaQuery, scrollTime, entityType), criteriaQuery));    }    /**     * @param scrollTime    the given scrollId.     * @param criteriaQuery the given query.     * @param clazz         the item domain type     * @param mapper        the mapper to transform results     * @return a {@link Page} of T instancess.     */    @Override    public <S extends T, T> Page<S> startScroll(Duration scrollTime, CriteriaQuery criteriaQuery, Class<T> clazz, SearchResultMapper mapper) {        SearchResponse response = startScrollResponse(scrollTime, criteriaQuery, clazz);        return mapper.mapResults(response, clazz);    }    /**     * @param scrollTime     * @param stringQuery     * @param entityType     * @param <T>     * @return     */    public <T> SearchResponse startScrollResponse(Duration scrollTime, StringQuery stringQuery, Class<T> entityType) {        return executeSearch(doScroll(prepareScroll(stringQuery, scrollTime, entityType), stringQuery));    }    /**     * @param scrollTime  the given scrollId.     * @param stringQuery the given query.     * @param clazz       the item domain type     * @param mapper      the mapper to transform results     * @return a {@link Page} of T instancess.     */    @Override    public <S extends T, T> Page<S> startScroll(Duration scrollTime, StringQuery stringQuery, Class<T> clazz, SearchResultMapper mapper) {        SearchResponse response = startScrollResponse(scrollTime, stringQuery, clazz);        return mapper.mapResults(response, clazz);    }    /**     * @param request     * @return     */    private SearchResponse executeSearch(SearchRequest request) {        try {            return client.search(request);        } catch (ElasticsearchStatusException e) {            if (e.status() == RestStatus.NOT_FOUND) {                return new SearchResponse(                        new SearchResponseSections(SearchHits.empty(), null, null, false, true, null, 0),                        null, 1, 1, 0, 1000, null, null);            }            throw buildSearchException(e, request);        } catch (IOException e) {            throw buildSearchException(e, request);        }    }    /**     * @see ElasticsearchOperations#continueScroll(String, Duration, Class)   method     */    @Override    public <S extends T, T> Page<S> continueScroll(String scrollId, Duration scrollTime, Class<T> clazz) {        return continueScroll(scrollId, scrollTime, clazz, this.getResultsMapper());    }    @Nullable    private SearchResponse continueScrollResponse(String scrollId, Duration scrollTime) {        SearchScrollRequest request = this.requestsBuilder().searchScrollRequest(scrollId, scrollTime);        try {            return client.searchScroll(request);        } catch (ElasticsearchStatusException e) {            if (e.status() == RestStatus.NOT_FOUND || e.status() == RestStatus.INTERNAL_SERVER_ERROR) {                return null;            }            throw new ElasticsearchException("Error for continue scroll request: " + request.toString(), e);        } catch (IOException e) {            throw new ElasticsearchException("Error for continue scroll request: " + request.toString(), e);        }    }    /**     * @param scrollId   the scroll id     * @param scrollTime the scroll time     * @param clazz      the entity class     * @param mapper     the mapper     * @param <T>        generic type     * @return a new {@link Page}     */    @Override    public <S extends T, T> Page<S> continueScroll(String scrollId, Duration scrollTime, Class<T> clazz, SearchResultMapper mapper) {        SearchResponse response = continueScrollResponse(scrollId, scrollTime);        if (response == null) {            return ScrolledPageResult.of(Collections.emptyList(), 0L, scrollId);        }        return mapper.mapResults(response, clazz);    }    /**     * @see ElasticsearchOperations#clearScroll(String)  method     */    @Override    public void clearScroll(String scrollId) {        ClearScrollRequest request = this.requestsBuilder().clearScrollRequest(scrollId);        try {            client.clearScroll(request);        } catch (ElasticsearchStatusException e) {            if (e.status() == RestStatus.NOT_FOUND) {                return;            }            throw buildClearScrollException(e, request);        } catch (IOException e) {            throw buildClearScrollException(e, request);        }    }    /**     * @see ElasticsearchOperations#deleteAll(Class)  method     */    @Override    public <T> void deleteAll(Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (persistentEntity.isRolloverIndex()) {            RolloverConfig rollover = persistentEntity.getRolloverConfig();            this.deleteIndexByAlias(persistentEntity.getAliasOrIndexWriter());            this.rolloverIndex(                    persistentEntity.getAliasOrIndexWriter(),                    persistentEntity.getIndexSettingAndMappingPath(),                    rollover.getConditions());        } else if (persistentEntity.isIndexTimeBased()) {            GetAliasesRequest request = this.requestsBuilder().getAliasesRequest(persistentEntity.getAliasOrIndexReader());            try {                GetAliasesResponse response = this.client.getAlias(request);                response.getAliases().keySet().forEach(this::deleteIndexByName);            }catch (ElasticsearchStatusException e){                if (e.status() != RestStatus.NOT_FOUND) {                    throw buildGetAliasException(e, request);                }            }catch (IOException e) {                throw buildGetAliasException(e, request);            }        } else {            deleteByQuery(persistentEntity.getAliasOrIndexReader(), persistentEntity.getTypeName(), QueryBuilders.matchAllQuery());        }    }    /**     * @see ElasticsearchOperations#deleteAll(Collection, Class)  method     */    @Override    public <T> void deleteAll(Collection<T> entities, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        Set<String> ids = new HashSet<>();        entities.forEach(entity -> {            String id = persistentEntity.getPersistentEntityId(entity);            if (id != null) {                ids.add(id);            }        });        if (!ids.isEmpty()) {            if (persistentEntity.isRolloverIndex()) {                deleteByQuery(persistentEntity.getAliasOrIndexWriter(), persistentEntity.getTypeName(), QueryBuilders.termsQuery("_id", ids));            } else {                deleteByQuery(persistentEntity.getAliasOrIndexReader(), persistentEntity.getTypeName(), QueryBuilders.termsQuery("_id", ids));            }        }    }    /**     * @see ElasticsearchOperations#delete(Object, Class)   method     */    @Override    public <T> void delete(T entity, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        String id = persistentEntity.getPersistentEntityId(entity);        if (id != null) {            this.deleteById(id, clazz);        }    }    /**     * delete the document for the given entity, and clazz     *     * @param query the given query.     * @param clazz the given clazz.     */    @Override    public <T> void delete(CriteriaQuery query, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        Optional<QueryBuilder> queryBuilder = new CriteriaQueryProcessor().createQueryFromCriteria(query.getCriteria());        Optional<QueryBuilder> filterBuilder = new CriteriaFilterProcessor().createFilterFromCriteria(query.getCriteria());        QueryBuilder deleteQuery = queryBuilder.orElse(filterBuilder.orElse(null));        if (persistentEntity.isRolloverIndex()) {            deleteByQuery(persistentEntity.getAliasOrIndexWriter(), persistentEntity.getTypeName(), deleteQuery);        } else {            deleteByQuery(persistentEntity.getAliasOrIndexReader(), persistentEntity.getTypeName(), deleteQuery);        }    }    /**     * @see ElasticsearchOperations#deleteById(String, Class)   method     */    @Override    public <T> void deleteById(String documentId, Class<T> clazz) {        Assert.notNull(documentId, "documentId must not be null!");        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        QueryBuilder queryBuilder = QueryBuilders.termQuery("_id", documentId);        if (persistentEntity.isIndexTimeBased()) {            deleteByQuery(persistentEntity.getAliasOrIndexReader(), persistentEntity.getTypeName(), queryBuilder);        } else {            String indexName = persistentEntity.isRolloverIndex() ? persistentEntity.getAliasOrIndexWriter() : persistentEntity.getAliasOrIndexReader();            DeleteRequest request = this.requestsBuilder().deleteRequest(indexName, persistentEntity.getTypeName(), documentId);            try {                client.delete(request);            } catch (IOException e) {                throw new ElasticsearchException("Error for delete request: " + request.toString(), e);            }        }    }    /**     * @param query     */    private void deleteByQuery(String indexName, String typeName, @Nullable QueryBuilder query) {        DeleteByQueryRequest request = this.requestsBuilder().deleteBy(indexName, typeName, query);        try {            BulkByScrollResponse response = client.deleteBy(request);            checkForBulkDeleteFailure(response);        }catch(ElasticsearchStatusException e){            if (e.status() != RestStatus.NOT_FOUND) {                throw new ElasticsearchException("Error while deleting bulk: " + request.toString(), e);            }        } catch (IOException e) {            throw new ElasticsearchException("Error while deleting bulk: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#refresh(Class)  method     */    @Override    public <T> void refresh(Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (persistentEntity.isRolloverIndex()) {            this.refresh(persistentEntity.getAliasOrIndexWriter());        } else {            this.refresh(persistentEntity.getAliasOrIndexReader());        }    }    /**     * @param indexName the index name     */    @Override    public void refresh(String indexName) {        Assert.notNull(indexName, "No index defined for refresh()");        try {            client.refresh(refreshRequest(indexName));        } catch (ElasticsearchStatusException e) {            if (e.status() == RestStatus.NOT_FOUND) {                return;            }            throw new ElasticsearchException("failed to refresh index: " + indexName, e);        } catch (IOException e) {            throw new ElasticsearchException("failed to refresh index: " + indexName, e);        }    }    @Override    public <T> T search(SearchQuery query, ResultsExtractor<T> resultsExtractor) {        SearchResponse response = executeSearch(doSearch(prepareSearch(query, Optional.of(query.getQuery())), query));        return resultsExtractor.extract(response);    }    /**     *     * @param <T>     * @param query     * @param extractor     * @return     */    @Override    public <T> T suggest(SuggestQuery query, ResultsExtractor<T> extractor) {        return extractor.extract(executeSearch(prepareSuggest(query)));    }    /**     *     * @param <R>     * @param <T>     * @param query     * @param clazz     * @param extractor     * @return     */    @Override    public <R, T> R suggest(SuggestQuery query, Class<T> clazz, ResultsExtractor<R> extractor) {        return extractor.extract(executeSearch(prepareSuggest(query, clazz)));    }    @Override    public <T> List hasChild(HasChildQuery query, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        return this.search(prepareHasChildQuery(query, clazz), persistentEntity.getJoinDescriptor().getParentJavaType());    }    @Override    public <S extends T, T> List<S> hasParent(HasParentQuery query, Class<T> clazz) {        return this.search(prepareHasParentQuery(query, clazz), clazz);    }    @Override    public <T> List<T> hasParentId(ParentIdQuery query, Class<T> clazz) {        return this.search(prepareHasParentId(query, clazz), clazz);    }    /**     *     * @param query     * @param builder     * @return     */    @Override    protected SearchRequest prepareSearch(Query query, Optional<QueryBuilder> builder) {        SearchRequest request = super.prepareSearch(query, builder);        SearchSourceBuilder sourceBuilder = request.source();        int startRecord = 0;        if (query.getPageable().isPaged()) {            startRecord = query.getPageable().getPageNumber() * query.getPageable().getPageSize();            sourceBuilder.size(query.getPageable().getPageSize());        }        sourceBuilder.from(startRecord);        return request;    }}