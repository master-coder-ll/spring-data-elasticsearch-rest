/* * Copyright (C) 2018 Yoann Despréaux * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; see the file COPYING . If not, write to the * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. * * Please send bugreports with examples or suggestions to yoann.despreaux@believeit.fr */package com.github.ydespreaux.spring.data.elasticsearch.repository;import com.github.ydespreaux.spring.data.elasticsearch.core.CriteriaQueryProcessor;import com.github.ydespreaux.spring.data.elasticsearch.core.ElasticsearchOperations;import com.github.ydespreaux.spring.data.elasticsearch.core.completion.EntitySuggestExtractor;import com.github.ydespreaux.spring.data.elasticsearch.core.mapping.ElasticsearchPersistentEntity;import com.github.ydespreaux.spring.data.elasticsearch.core.query.*;import com.github.ydespreaux.spring.data.elasticsearch.core.scroll.ScrolledPage;import com.github.ydespreaux.spring.data.elasticsearch.repository.support.ElasticsearchEntityInformation;import org.apache.lucene.search.join.ScoreMode;import org.elasticsearch.common.unit.Fuzziness;import org.elasticsearch.index.query.QueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.sort.SortBuilders;import org.elasticsearch.search.sort.SortOrder;import org.elasticsearch.search.suggest.SuggestBuilder;import org.elasticsearch.search.suggest.SuggestBuilders;import org.elasticsearch.search.suggest.SuggestionBuilder;import org.springframework.dao.InvalidDataAccessApiUsageException;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.lang.NonNull;import org.springframework.lang.Nullable;import org.springframework.util.Assert;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.time.Duration;import java.util.Collection;import java.util.List;import java.util.Optional;/** * @param <T> entity generic class * @param <K> key generic class * @author Yoann Despréaux * @since 1.0.0 */public abstract class AbstractElasticsearchRepository<T, K> implements ElasticsearchRepository<T, K> {    protected final ElasticsearchOperations elasticsearchOperations;    protected ElasticsearchEntityInformation<T, K> entityInformation;    private Class<T> entityClass;    public AbstractElasticsearchRepository(ElasticsearchOperations elasticsearchOperations) {        this.elasticsearchOperations = elasticsearchOperations;    }    /**     * @param metadata                the entity metadata     * @param elasticsearchOperations a {@link ElasticsearchOperations}     */    public AbstractElasticsearchRepository(ElasticsearchEntityInformation<T, K> metadata, ElasticsearchOperations elasticsearchOperations) {        this(elasticsearchOperations);        //        this.entityInformation = metadata;        this.entityClass = this.entityInformation.getJavaType();        this.elasticsearchOperations.createIndex(getEntityClass());    }    /**     * @return entity class     */    public Class<T> getEntityClass() {        if (!isEntityClassSet()) {            try {                this.entityClass = resolveReturnedClassFromGenericType();            } catch (Exception e) {                throw new InvalidDataAccessApiUsageException("Unable to resolve EntityClass. Please use according setter!", e);            }        }        return entityClass;    }    /**     * @param id must not be {@literal null}.     * @return a document     */    @Override    public Optional<T> findById(K id) {        assertNotNullId(id);        return Optional.ofNullable(elasticsearchOperations.findById(getEntityClass(), stringIdRepresentation(id)));    }    /**     * @return     */    @Override    public List<T> findAll() {        return this.findByQuery(QueryBuilders.matchAllQuery(), Sort.unsorted());    }    /**     * @param pageable     * @return     */    @Override    public ScrolledPage<T> findAll(Pageable pageable) {        return this.findByQuery(QueryBuilders.matchAllQuery(), pageable);    }    @Override    public boolean existsById(K id) {        assertNotNullId(id);        return elasticsearchOperations.existsById(getEntityClass(), stringIdRepresentation(id));    }    /**     * @return     */    @Override    public long count() {        return count(QueryBuilders.matchAllQuery());    }    /**     * @param query     * @return     */    @Override    public long count(QueryBuilder query) {        NativeSearchQuery.NativeSearchQueryBuilder builder = new NativeSearchQuery.NativeSearchQueryBuilder()                .withQuery(query);        return this.elasticsearchOperations.count(builder.build(), this.getEntityClass());    }    /**     * @param criteria     * @return     */    @Override    public long count(Criteria criteria) {        return this.elasticsearchOperations.count(new CriteriaQuery(criteria), this.getEntityClass());    }    /**     * Saves a given entity. Use the returned instance for further operations as the save operation might have changed the     * entity instance completely.     *     * @param entity must not be {@literal null}.     * @return the saved entity will never be {@literal null}.     */    @Override    public T save(T entity) {        Assert.notNull(entity, "Cannot save 'null' entity.");        return this.elasticsearchOperations.index(entity, getEntityClass());    }    /**     * Saves all given entities.     *     * @param entities must not be {@literal null}.     * @return the saved entities will never be {@literal null}.     * @throws IllegalArgumentException in case the given entity is {@literal null}.     */    @Override    public List<T> save(List<T> entities) {        Assert.notNull(entities, "Cannot insert 'null' as a List.");        Assert.notEmpty(entities, "Cannot insert empty List.");        return this.elasticsearchOperations.bulkIndex(entities, getEntityClass());    }    /**     * Deletes the entity with the given id.     *     * @param id must not be {@literal null}.     * @throws IllegalArgumentException in case the given {@code id} is {@literal null}     */    @Override    public void deleteById(K id) {        assertNotNullId(id);        this.elasticsearchOperations.deleteById(stringIdRepresentation(id), getEntityClass());    }    /**     * Deletes a given entity.     *     * @param entity the entity to delete     * @throws IllegalArgumentException in case the given entity is {@literal null}.     */    @Override    public void delete(T entity) {        Assert.notNull(entity, "Cannot delete 'null' entity.");        this.elasticsearchOperations.delete(entity, getEntityClass());    }    /**     * Deletes the given entities.     *     * @param entities the entities     * @throws IllegalArgumentException in case the given {@link Iterable} is {@literal null}.     */    @Override    public void deleteAll(Collection<T> entities) {        Assert.notNull(entities, "Cannot delete 'null' as a List.");        Assert.notEmpty(entities, "Cannot delete empty List.");        this.elasticsearchOperations.deleteAll(entities, getEntityClass());    }    /**     * Deletes all entities managed by the repository.     */    @Override    public void deleteAll() {        this.elasticsearchOperations.deleteAll(getEntityClass());    }    /**     *     */    @Override    public void refresh() {        this.elasticsearchOperations.refresh(getEntityClass());    }    /**     * @param query the query     * @return the list items     */    @Override    public <S extends T> List<S> findByQuery(QueryBuilder query, Sort sort) {        return findByQuery(query, sort, this.getEntityClass());    }    /**     * @param criteria the query     * @param sort     the sort     * @return items for the query     */    @Override    public <S extends T> List<S> findByQuery(Criteria criteria, Sort sort) {        return findByQuery(criteria, sort, this.getEntityClass());    }    /**     * @param query     * @param sort     * @param domainClass     * @return     */    @Override    public <S extends D, D> List<S> findByQuery(QueryBuilder query, Sort sort, Class<D> domainClass) {        NativeSearchQuery.NativeSearchQueryBuilder queryBuilder = new NativeSearchQuery.NativeSearchQueryBuilder().withQuery(query);        if (sort != null) {            sort.forEach(order -> queryBuilder.withSort(SortBuilders.fieldSort(order.getProperty()).order(order.isAscending() ? SortOrder.ASC : SortOrder.DESC)));        }        return this.elasticsearchOperations.search(queryBuilder.build(), domainClass);    }    /**     * @param criteria     * @param sort     * @param domainClass     * @return     */    @Override    public <S extends D, D> List<S> findByQuery(Criteria criteria, Sort sort, Class<D> domainClass) {        CriteriaQuery query = new CriteriaQuery(criteria);        if (sort != null) {            query.addSort(sort);        }        return this.elasticsearchOperations.search(query, domainClass);    }    /**     * @param query    the query     * @param pageable the pageable     * @return a new {@link ScrolledPage}     */    @Override    public <S extends T> ScrolledPage<S> findByQuery(QueryBuilder query, Pageable pageable) {        return findByQuery(query, pageable, getEntityClass());    }    /**     * Start new continueScroll with scroll api     *     * @param criteria the query     * @param pageable the pageable     * @return a new {@link ScrolledPage}     */    @Override    public <S extends T> ScrolledPage<S> findByQuery(Criteria criteria, Pageable pageable) {        return findByQuery(criteria, pageable, getEntityClass());    }    /**     * Start new continueScroll with scroll api     *     * @param query       the query     * @param pageable    the pageable     * @param domainClass     * @return a new {@link ScrolledPage}     */    @Override    public <S extends D, D> ScrolledPage<S> findByQuery(QueryBuilder query, Pageable pageable, Class<D> domainClass) {        assertNotNullPageable(pageable);        NativeSearchQuery.NativeSearchQueryBuilder queryBuilder = new NativeSearchQuery.NativeSearchQueryBuilder()                .withPageable(pageable)                .withQuery(query);        return this.elasticsearchOperations.startScroll(queryBuilder.build(), domainClass);    }    /**     * Start new continueScroll with scroll api     *     * @param criteria    the query     * @param pageable    the pageable     * @param domainClass     * @return a new {@link ScrolledPage}     */    @Override    public <S extends D, D> ScrolledPage<S> findByQuery(Criteria criteria, Pageable pageable, Class<D> domainClass) {        assertNotNullPageable(pageable);        CriteriaQuery query = new CriteriaQuery(criteria, pageable);        return this.elasticsearchOperations.startScroll(query, domainClass);    }    /**     * @param scrollId     * @param scrollTime     * @return     */    @Override    public <S extends T> ScrolledPage<S> continueScroll(String scrollId, Duration scrollTime) {        return continueScroll(scrollId, scrollTime, getEntityClass());    }    /**     * @param scrollId     * @param scrollTime     * @param domainClass     * @param <D>     * @return     */    @Override    public <S extends D, D> ScrolledPage<S> continueScroll(String scrollId, Duration scrollTime, Class<D> domainClass) {        Assert.notNull(scrollId, "scrollId must not be null!");        return this.elasticsearchOperations.continueScroll(scrollId, scrollTime, domainClass);    }    /**     * @param scrollId the scroll id     */    @Override    public void clearSearch(String scrollId) {        Assert.notNull(scrollId, "scrollId must not be null!");        this.elasticsearchOperations.clearScroll(scrollId);    }    /**     * @param query     * @return     */    @Override    public List<T> suggest(String query) {        return this.suggest(query, getEntityClass());    }    /**     * @param query     * @param domainClass     * @return     */    @Override    public <D> List<D> suggest(String query, Class<D> domainClass) {        ElasticsearchPersistentEntity<T> persistentEntity = this.elasticsearchOperations.getPersistentEntityFor(getEntityClass());        if (!persistentEntity.hasCompletionProperty()) {            throw new InvalidDataAccessApiUsageException("No completion property field defined");        }        SuggestionBuilder completionSuggestionFuzzyBuilder = SuggestBuilders.completionSuggestion(persistentEntity.getCompletionProperty().getFieldName()).prefix(query, Fuzziness.AUTO);        return elasticsearchOperations.suggest(                new SuggestQuery(new SuggestBuilder().addSuggestion("suggest-" + domainClass.getName(), completionSuggestionFuzzyBuilder)),                domainClass,                new EntitySuggestExtractor<>(domainClass, this.elasticsearchOperations.getResultsMapper()));    }    @Override    public List hasChild() {        return hasChildByQuery(QueryBuilders.matchAllQuery());    }    @Override    public List hasChildByQuery(@NonNull Criteria criteria) {        return hasChildByQuery(new CriteriaQueryProcessor().createQueryFromCriteria(criteria));    }    @Override    public List hasChildByQuery(@NonNull QueryBuilder query) {        assertChildDocument();        return this.elasticsearchOperations.hasChild(                HasChildQuery.builder()                        .type(this.entityInformation.getJoinDescriptor().getType())                        .query(query)                        .scoreMode(ScoreMode.None)                        .build(), this.getEntityClass());    }    @Override    public <S extends T> List<S> hasParent() {        return hasParentByQuery(QueryBuilders.matchAllQuery());    }    @Override    public <S extends T> List<S> hasParentByQuery(@NonNull Criteria criteria) {        return hasParentByQuery(new CriteriaQueryProcessor().createQueryFromCriteria(criteria));    }    @Override    public <S extends T> List<S> hasParentByQuery(@NonNull QueryBuilder query) {        assertParentDocument();        return this.elasticsearchOperations.hasParent(HasParentQuery.builder().type(this.entityInformation.getJoinDescriptor().getType()).query(query).build(), this.getEntityClass());    }    @Override    public List<T> hasParentId(@NonNull String parentId) {        return hasParentId(parentId, (QueryBuilder) null);    }    @Override    public List<T> hasParentId(@NonNull String parentId, @Nullable Criteria criteria) {        return hasParentId(parentId, new CriteriaQueryProcessor().createQueryFromCriteria(criteria));    }    @Override    public List<T> hasParentId(@NonNull String parentId, @Nullable QueryBuilder query) {        assertChildDocument();        return this.elasticsearchOperations.hasParentId(                ParentIdQuery.builder().type(this.entityInformation.getJoinDescriptor().getType()).parentId(parentId).query(query).build(), this.getEntityClass());    }    /**     * @param id the identifier     * @return the string representation     */    protected abstract String stringIdRepresentation(K id);    /**     * @return     */    private boolean isEntityClassSet() {        return entityClass != null;    }    /**     * @return     */    private Class<T> resolveReturnedClassFromGenericType() {        ParameterizedType parameterizedType = resolveReturnedClassFromGenericType(getClass());        return (Class<T>) parameterizedType.getActualTypeArguments()[0];    }    /**     * @param clazz     * @return     */    private ParameterizedType resolveReturnedClassFromGenericType(Class<?> clazz) {        Object genericSuperclass = clazz.getGenericSuperclass();        if (genericSuperclass instanceof ParameterizedType) {            ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;            Type rawtype = parameterizedType.getRawType();            if (SimpleElasticsearchRepository.class.equals(rawtype)) {                return parameterizedType;            }        }        return resolveReturnedClassFromGenericType(clazz.getSuperclass());    }    /**     * @param id     */    private void assertNotNullId(K id) {        Assert.notNull(id, "id must not be null!");    }    private void assertNotNullPageable(Pageable pageable) {        Assert.notNull(pageable, "pageable is required");    }    private void assertChildDocument() {        if (!this.entityInformation.isChildDocument()) {            throw new InvalidDataAccessApiUsageException("The document must be a child document !!!");        }    }    private void assertParentDocument() {        if (!this.entityInformation.isParentDocument()) {            throw new InvalidDataAccessApiUsageException("The document must be a parent document !!!");        }    }}