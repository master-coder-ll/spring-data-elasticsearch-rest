/* * Copyright (C) 2018 Yoann Despréaux * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; see the file COPYING . If not, write to the * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. * * Please send bugreports with examples or suggestions to yoann.despreaux@believeit.fr */package com.github.ydespreaux.spring.data.elasticsearch.repository.support;import com.github.ydespreaux.spring.data.elasticsearch.AbstractElasticsearchTest;import com.github.ydespreaux.spring.data.elasticsearch.client.ClientLoggerAspect;import com.github.ydespreaux.spring.data.elasticsearch.configuration.ElasticsearchConfigurationSupport;import com.github.ydespreaux.spring.data.elasticsearch.core.scroll.ScrolledPage;import com.github.ydespreaux.spring.data.elasticsearch.entities.Book;import com.github.ydespreaux.spring.data.elasticsearch.repositories.synonyms.BookRepository;import com.github.ydespreaux.spring.data.elasticsearch.repository.config.EnableElasticsearchRepositories;import com.github.ydespreaux.testcontainers.elasticsearch.ElasticsearchContainer;import org.elasticsearch.index.query.QueryBuilders;import org.junit.Before;import org.junit.ClassRule;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;import org.springframework.context.annotation.Profile;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.test.context.junit4.SpringRunner;import java.time.Clock;import java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.util.*;import static org.hamcrest.Matchers.*;import static org.junit.Assert.assertThat;import static org.junit.Assert.assertTrue;/** * @author Yoann Despréaux * @since 1.0.0 */@RunWith(SpringRunner.class)@SpringBootTest(classes = {        RestClientAutoConfiguration.class,        ITBookRepositoryTest.ElasticsearchConfiguration.class})@Profile("test-no-template")public class ITBookRepositoryTest extends AbstractElasticsearchTest<Book> {    @ClassRule    public static final ElasticsearchContainer elasticContainer = new ElasticsearchContainer("6.4.2")            .withConfigDirectory("elastic-config");    public ITBookRepositoryTest() {        super(Book.class);    }    @Autowired    private BookRepository repository;    @Override    protected List<Book> generateData() {        List<Book> books = new ArrayList<>();        books.add(createBook(                "Black City Parade",                "Exceptionnel : pour la 1ère fois ! Indochine records et Sony Music sont fiers de proposer les rééditions des 12 albums studio d’Indochine...",                15d,                LocalDate.of(2015, 10, 25)));        books.add(createBook(                "Blake et Mortimer - Tome 25 : La vallée des immortels",                "À Lhassa, le palais impérial du dictateur Basam-Damdu est anéanti par une escadrille d’Espadons, et le monde, soulagé, fête la fin de la troisième guerre mondiale...",                25d,                LocalDate.of(2016, 5, 1)));        books.add(createBook(                "Et puis Colette",                "Anouk, trentenaire parisienne enfermée dans la routine, vient d’apprendre le décès de sa soeur...",                9.99d,                LocalDate.of(2017, 2, 1)));        books.add(createBook(                "Live Is love Double Vinyle",                "Thomas s’est pour ce disque mis à nu, sans concession aucune...",                12.20d,                LocalDate.of(2018, 7, 10)));        books.add(createBook(                "Zorro - Cicatrices Tome 01 : Zorro",                "Zorro est toujours Don Diego de la Vega sous le masque, et il défend toujours la veuve et l’orphelin grâce à son fouet et son épée. Mais il est cette fois aux prises avec l’amour !",                5d,                null));        return books;    }    @Before    public void setUp() {        cleanData();    }    @Configuration    @EnableAspectJAutoProxy    @EnableAutoConfiguration    @EnableElasticsearchRepositories(            basePackages = "com.github.ydespreaux.spring.data.elasticsearch.repositories.synonyms")    static class ElasticsearchConfiguration extends ElasticsearchConfigurationSupport {        @Bean        ClientLoggerAspect clientLoggerAspect() {            return new ClientLoggerAspect();        }    }    @Test    public void findById() {        List<Book> data = insertData();        Book myBook = data.get(0);        Optional<Book> optionalBook = this.repository.findById(myBook.getDocumentId());        assertTrue(optionalBook.isPresent());        Book bookLoaded = optionalBook.get();        assertThat(bookLoaded.getDocumentId(), is(equalTo(myBook.getDocumentId())));        assertThat(bookLoaded.getTitle(), is(equalTo(myBook.getTitle())));        assertThat(bookLoaded.getDescription(), is(equalTo(myBook.getDescription())));        assertThat(bookLoaded.getPrice(), is(equalTo(myBook.getPrice())));        assertThat(bookLoaded.getPublication(), is(equalTo(myBook.getPublication())));        assertThat(bookLoaded.getVersion(), is(equalTo(1L)));    }    @Test    public void findByIdNotFound() {        Optional<Book> optionalBook = this.repository.findById(UUID.randomUUID().toString());        assertThat(optionalBook.isPresent(), is(false));    }    @Test    public void existsById() {        List<Book> data = insertData();        Book myBook = data.get(0);        assertThat(this.repository.existsById(myBook.getDocumentId()), is(true));    }    @Test    public void notExistsById() {        assertThat(this.repository.existsById(UUID.randomUUID().toString()), is(false));    }    @Test    public void save() {        Book book = createBook("New book", "Description", 10.5d, LocalDate.now(Clock.systemUTC()));        Book bookIndexed = this.repository.save(book);        this.repository.refresh();        assertThat(bookIndexed.getTitle(), is(equalTo(book.getTitle())));        assertThat(bookIndexed.getDescription(), is(equalTo(book.getDescription())));        assertThat(bookIndexed.getPrice(), is(equalTo(book.getPrice())));        assertThat(bookIndexed.getPublication(), is(equalTo(book.getPublication())));        assertThat(bookIndexed.getVersion(), is(equalTo(1L)));    }    @Test    public void save_bulk() {        List<Book> books = new ArrayList<>();        books.add(createBook("new_Livre1", "Description du livre 1", 10.5d, LocalDate.now(Clock.systemUTC())));        books.add(createBook("new_Livre2", "Description du livre 2", 8d, LocalDate.now(Clock.systemUTC())));        books.add(createBook("new_Livre3", "Description du livre 3", 20d, LocalDate.now(Clock.systemUTC())));        books.add(createBook("new_Livre4", "Description du livre 4", 5d, LocalDate.now(Clock.systemUTC())));        books.add(createBook("new_Livre5", "Description du livre 5", 8.5d, LocalDate.now(Clock.systemUTC())));        List<Book> booksIndexed = this.repository.save(books);        this.repository.refresh();        assertThat(booksIndexed.size(), is(equalTo(books.size())));        for (Book bookIndexed : booksIndexed) {            assertThat(bookIndexed.getDocumentId(), is(notNullValue()));            assertThat(bookIndexed.getVersion(), is(equalTo(1L)));        }    }    @Test    public void deleteById() {        List<Book> data = insertData();        Book myBook = data.get(0);        this.repository.deleteById(myBook.getDocumentId());        this.repository.refresh();        Optional<Book> optional = this.repository.findById(myBook.getDocumentId());        assertThat(optional.isPresent(), is(false));    }    @Test    public void delete() {        List<Book> data = insertData();        Book myBook = data.get(0);        this.repository.delete(myBook);        this.repository.refresh();        Optional<Book> optional = this.repository.findById(myBook.getDocumentId());        assertThat(optional.isPresent(), is(false));    }    @Test    public void deleteAll() {        List<Book> data = insertData();        List<Book> books = Arrays.asList(data.get(0), data.get(1), data.get(2));        this.repository.deleteAll(books);        this.repository.refresh();        for (Book bookIndexed : books) {            Optional<Book> optional = this.repository.findById(bookIndexed.getDocumentId());            assertThat(optional.isPresent(), is(false));        }    }    @Test    public void searchByPrice_withoutSort() {        insertData();        List<Book> result = this.repository.findByQuery(QueryBuilders.rangeQuery("price").from(5).to(10), (Sort) null);        assertThat(result.size(), is(equalTo(2)));        for (Book book : result) {            assertThat(book.getDocumentId(), is(notNullValue()));            assertThat(book.getVersion(), is(notNullValue()));        }    }    @Test    public void searchByPrice_withSortByPrice() {        List<Book> data = insertData();        List<Book> result = this.repository.findByQuery(QueryBuilders.rangeQuery("price").from(5).to(10), Sort.by(Sort.Direction.DESC, "price"));        assertThat(result.size(), is(equalTo(2)));        for (Book book : result) {            assertThat(book.getDocumentId(), is(notNullValue()));            assertThat(book.getVersion(), is(notNullValue()));        }        assertThat(result.get(0).getTitle(), is(equalTo(data.get(2).getTitle())));        assertThat(result.get(1).getTitle(), is(equalTo(data.get(4).getTitle())));    }    @Test    public void searchAllWithScrollAndSorByTitleAsc() {        List<Book> data = insertData();        Pageable pageable = PageRequest.of(0, 2, Sort.by(Sort.Direction.ASC, "title"));        ScrolledPage<Book> result = this.repository.findByQuery(QueryBuilders.matchAllQuery(), pageable);        String scrollId = result.getScrollId();        assertThat(scrollId, is(notNullValue()));        assertThat(result.getTotalElements(), is(equalTo(5L)));        assertThat(result.getContent().size(), is(equalTo(2)));        assertThat(result.getContent().get(0).getTitle(), is(equalTo(data.get(0).getTitle())));        assertThat(result.getContent().get(1).getTitle(), is(equalTo(data.get(1).getTitle())));        result = this.repository.continueScroll(scrollId, Duration.ofMinutes(1));        assertThat(result.getTotalElements(), is(equalTo(5L)));        assertThat(result.getContent().size(), is(equalTo(2)));        assertThat(result.getContent().get(0).getTitle(), is(equalTo(data.get(2).getTitle())));        assertThat(result.getContent().get(1).getTitle(), is(equalTo(data.get(3).getTitle())));        result = this.repository.continueScroll(scrollId, Duration.ofMinutes(1));        assertThat(result.getTotalElements(), is(equalTo(5L)));        assertThat(result.getContent().size(), is(equalTo(1)));        assertThat(result.getContent().get(0).getTitle(), is(equalTo(data.get(4).getTitle())));        result = this.repository.continueScroll(scrollId, Duration.ofMinutes(1));        assertThat(result.getTotalElements(), is(equalTo(5L)));        assertThat(result.getContent().size(), is(equalTo(0)));    }    @Test    public void searchAllWithScrollAndSorByPublicationDesc() {        List<Book> data = insertData();        Pageable pageable = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, "publication"));        ScrolledPage<Book> result = this.repository.findByQuery(QueryBuilders.matchAllQuery(), pageable);        String scrollId = result.getScrollId();        assertThat(scrollId, is(notNullValue()));        assertThat(result.getTotalElements(), is(equalTo(5L)));        assertThat(result.getContent().size(), is(equalTo(5)));        assertThat(result.getContent().get(0).getTitle(), is(equalTo(data.get(3).getTitle())));        assertThat(result.getContent().get(1).getTitle(), is(equalTo(data.get(2).getTitle())));        assertThat(result.getContent().get(2).getTitle(), is(equalTo(data.get(1).getTitle())));        assertThat(result.getContent().get(3).getTitle(), is(equalTo(data.get(0).getTitle())));        assertThat(result.getContent().get(4).getTitle(), is(equalTo(data.get(4).getTitle())));    }    @Test    public void findByDescriptionContains() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionContains("pour");        assertThat(result.size(), is(equalTo(2)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    @Test    public void findByDescriptionNotContains() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionNotContains("pour");        assertThat(result.size(), is(equalTo(3)));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(2)), is(true));        assertThat(result.contains(data.get(4)), is(true));    }    @Test    public void findByDescriptionContaining() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionContaining("pour");        assertThat(result.size(), is(equalTo(2)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    @Test    public void findByDescriptionNotContaining() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionNotContaining("pour");        assertThat(result.size(), is(equalTo(3)));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(2)), is(true));        assertThat(result.contains(data.get(4)), is(true));    }    @Test    public void findByDescriptionContainsWithSynonym() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionContains("for");        assertThat(result.size(), is(equalTo(2)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    @Test    public void findByDescriptionEndsWith() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionEndsWith("...");        assertThat(result.size(), is(equalTo(4)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(2)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    @Test    public void findByDescriptionEndingWith() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionEndingWith("...");        assertThat(result.size(), is(equalTo(4)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(2)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    @Test    public void findByDescriptionStartsWith() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionStartsWith("Zorro");        assertThat(result.size(), is(equalTo(1)));        assertThat(result.contains(data.get(4)), is(true));    }    @Test    public void findByTitleIn() {        List<Book> data = insertData();        List<Book> result = this.repository.findByTitleIn(                new String[]{                        data.get(0).getTitle(),                        data.get(3).getTitle()                }        );        assertThat(result.size(), is(equalTo(2)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    @Test    public void findByTitleNotIn() {        List<Book> data = insertData();        List<Book> result = this.repository.findByTitleNotIn(                new String[]{                        data.get(0).getTitle(),                        data.get(3).getTitle()                }        );        assertThat(result.size(), is(equalTo(3)));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(2)), is(true));        assertThat(result.contains(data.get(4)), is(true));    }    @Test    public void findByTitleInWithCollections() {        List<Book> data = insertData();        List<Book> result = this.repository.findByTitleIn(                Arrays.asList(                        data.get(0).getTitle(),                        data.get(3).getTitle()                )        );        assertThat(result.size(), is(equalTo(2)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    @Test    public void findByTitleNotInWithCollections() {        List<Book> data = insertData();        List<Book> result = this.repository.findByTitleNotIn(                Arrays.asList(                        data.get(0).getTitle(),                        data.get(3).getTitle()                )        );        assertThat(result.size(), is(equalTo(3)));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(2)), is(true));        assertThat(result.contains(data.get(4)), is(true));    }    @Test    public void findByDescriptionMatches() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionMatches("Indochine");        assertThat(result.size(), is(equalTo(1)));        assertThat(result.contains(data.get(0)), is(true));    }    @Test    public void findByDescriptionLike() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionLike("Indochine");        assertThat(result.size(), is(equalTo(1)));        assertThat(result.contains(data.get(0)), is(true));    }    @Test    public void findByDescriptionNotLike() {        List<Book> data = insertData();        List<Book> result = this.repository.findByDescriptionNotLike("Indochine");        assertThat(result.size(), is(equalTo(4)));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(2)), is(true));        assertThat(result.contains(data.get(3)), is(true));        assertThat(result.contains(data.get(4)), is(true));    }    @Test    public void findByPublication() {        List<Book> data = insertData();        List<Book> result = this.repository.findByPublication(LocalDate.of(2016, 5, 1));        assertThat(result.size(), is(equalTo(1)));        assertThat(result.contains(data.get(1)), is(true));    }    @Test    public void findByPublicationAfter() {        List<Book> data = insertData();        List<Book> result = this.repository.findByPublicationAfter(LocalDate.of(2016, 5, 1));        assertThat(result.size(), is(equalTo(3)));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(2)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    @Test    public void findByPublicationBefore() {        List<Book> data = insertData();        List<Book> result = this.repository.findByPublicationBefore(LocalDate.of(2016, 5, 1));        assertThat(result.size(), is(equalTo(2)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(1)), is(true));    }    @Test    public void findByPublicationBetween() {        List<Book> data = insertData();        List<Book> result = this.repository.findByPublicationBetween(LocalDate.of(2016, 5, 1), LocalDate.of(2017, 2, 1));        assertThat(result.size(), is(equalTo(2)));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(2)), is(true));    }    @Test    public void findByPriceGreaterThan() {        List<Book> data = insertData();        List<Book> result = this.repository.findByPriceGreaterThan(9.99d);        assertThat(result.size(), is(equalTo(3)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(1)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    @Test    public void findByPriceLessThan() {        List<Book> data = insertData();        List<Book> result = this.repository.findByPriceLessThan(9.99d);        assertThat(result.size(), is(equalTo(1)));        assertThat(result.contains(data.get(4)), is(true));    }    @Test    public void findByPriceBetween() {        List<Book> data = insertData();        List<Book> result = this.repository.findByPriceBetween(10, 20);        assertThat(result.size(), is(equalTo(2)));        assertThat(result.contains(data.get(0)), is(true));        assertThat(result.contains(data.get(3)), is(true));    }    /**     * @param title     * @param description     * @param price     * @return     */    private Book createBook(String title, String description, Double price, LocalDate publication) {        return Book.builder()                .title(title)                .description(description)                .price(price)                .publication(publication)                .lastUpdated(LocalDateTime.now(Clock.systemUTC()))                .build();    }}